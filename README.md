####HHPLUS TDD WEEK 1

#### 요구사항
- PATCH /point/{id}/charge : 포인트를 충전한다.
- PATCH /point/{id}/use : 포인트를 사용한다.
- GET /point/{id} : 포인트를 조회한다.
- GET /point/{id}/histories : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다. (동시성)

#### 동시성 제어 방식
동시성(Concurrency Control)이란?
다중 사용자 환경을 지원하는 DB 시스템에서 동시에 실행되는 여러 트랜잭션 간의 간섭으로 문제가 발생하지 않도록 트랜잭션의 실행 순서를 제어하는 기법

## 동시성은 왜 필요할까?
다중 사용자 DBMS의 경우 한 트랜잭션이 실행되는 동시에 다른 트랜잭션이 끼어들 수 있다.
다른 트랜잭션이 간섭함으로 갱신 분실(lost update), 연쇄 복귀(cascading rollback), 회복 불가능(Unrecoverability), 불일치 분석(inconsistent analysis) 문제가 발생할 수 있다.
갱신 분실 : 트랜잭션들이 동일한 데이터를 동시에 갱신하는 경우 발생 -> update 한 데이터를 또 update 하여 나타나는 문제
불일치 분석 : 여러 개의 트랜잭션이 동시에 실행함으로 일관성이 유지되지 못하는 문제
연쇄복귀 or 회복불가능 : 여러 개의 트랜잭션이 데이터를 공유할 때 한 트랜잭션이 이전 상태로 복귀하면 다른 트랜잭션까지 복귀하는 문제
-> 동시성 제어는 이런 문제들을 방지하고 데이터의 무결성 및 일관성을 보장함

![image](https://github.com/user-attachments/assets/cf8f8f2f-a350-410e-b01a-b1b174f82c50)
20000이 되어야 하는데 19601이 나옵니다.
이유는 두 스레드가 하나의 자원에 접근하여서 동기화 되지 않은 데이터의 결과입니다.

## 동시성 해결
동시성 문제를 해결하기 위해 ReentrantLock을 사용하여 명시적 락을 통한 동시성 제어를 구현했습니다. 이 방법을 사용하여 다중 스레드 환경에서 동일 자원(포인트)에 대한 접근 및 수정이 동시에 발생할 때 데이터 무결성 및 일관성을 보장할 수 있도록 하였습니다.

1. ReentrantLock을 통한 동시성 제어
ReentrantLock을 사용하면, 명시적으로 락을 걸고 해제할 수 있으며, 락을 걸고 있는 동안 다른 스레드가 해당 자원에 접근하지 못하게 차단할 수 있습니다. charge() 메서드와 use() 메서드에서 락을 걸어 자원에 대한 동시 접근을 방지하였습니다. 이를 통해, 여러 스레드가 동시에 동일한 사용자 포인트를 수정하려는 상황에서 **경쟁 상태(Race Condition)**를 피할 수 있습니다.

![image](https://github.com/user-attachments/assets/4e302ca7-a6ce-4594-9d6a-49ed82cf99f7)

## 결론
ReentrantLock을 사용한 동시성 제어를 통해 동시 작업 간 데이터 일관성을 보장했습니다. 이를 통해 여러 스레드가 같은 자원에 접근하여 발생할 수 있는 경쟁 상태를 방지할 수 있었습니다.

## 다음에 Synchronizatio 을 이용한 동시성 테스트를 진행해보겠습니다.
